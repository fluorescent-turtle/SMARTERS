# Place a grass tassel agent
        for contents, (x, y) in self.grid.coord_iter():
            new_tassel = GrassTassel((x, y), self, tassel_dim)
            new_tassel.condition = "High"
            self.grid.place_agent(new_tassel, (x, y))
            self.schedule.add(new_tassel)



        entrance_x, entrance_y = (random.randrange(1,
                                                   environment_data['isolated_area_width'] - 1),
                                  random.randrange(1, environment_data['isolated_area_length'] - 1)
                                  )

--------------------
    def get_circles(self):
        """
        Get the positions of all circular isolated areas.

        Returns:
            list: List of positions.
        """
        return [
            c.pos
            for c in self.grid.get_cell_list_contents
            if isinstance(c, CircularIsolation)
        ]

    def get_blocked_circles(self):
        """
        Get the positions of all circular isolated areas.

        Returns:
            list: List of positions.
        """
        return [
            c.pos
            for c in self.grid.get_cell_list_contents()
            if isinstance(c, CircledBlockedArea)
        ]


        ------------__>in can_place
         """and not any(
                    euclidean_distance(pos, c) <= self.radius for c in self.get_circles()
                )"""


--------------------------------------------------------------------------------------------------------------------------------------------------------- base station
         # Add the base station to the grid
        self.add_base_station(self.position)

        adjacent_position = (self.position[0] + 1, position[1] + 1)
        if self.within_bounds(adjacent_position) and not self.grid.is_cell_occupied(
            adjacent_position
        ):
            self.add_resource(
                BaseStation(
                    (adjacent_position[0], adjacent_position[1]), position[0], self
                ),
                adjacent_position[0],
                adjacent_position[1],
            )
            self.resources.append(adjacent_position)
            self.schedule.add(
                BaseStation(
                    (adjacent_position[0], adjacent_position[1]), position[0], self
                )
            )
        else:
            print("Adjacent position is outside the grid or already occupied.")


            # todo: problem
        biggest_area, coords = self.find_largest_blocked_area()
        # Calculate position for the base station
        self.base_station_position = calculate_position(
            self, center, coords, self.width, self.length
        )
        # Add the base station to the grid
        add_two_base_stations(self, self.position)


-------------------> moving agent
# todo: problem
        # Add a moving agent to the grid
        if position[0] < 0:
            if self.grid.is_cell_empty(
                (self.base_station_position[0] + 1, self.base_station_position[1] + 1)
            ):
                moving_agent = MovingAgent(
                    1,
                    self,
                    self.grid,
                    (
                        self.base_station_position[0] + 1,
                        self.base_station_position[1] + 1,
                    ),
                    self.resources,
                )
                self.add_resource(
                    moving_agent,
                    self.base_station_position[0] + 1,
                    self.base_station_position[1] + 1,
                )
                print("IF DOPO IL MOVING AGENT ---------------- DOPO LA ADD RESOURCE")
                self.schedule.add(moving_agent)
            else:
                print("self.base_statoin_position is not empty")
        else:
            # Definire gli offset per le direzioni cardinali (sopra, sotto, a sinistra, a destra)
            directions = [(0, 1), (0, -1), (-1, 0), (1, 0)]

            # Scorrere tutte le direzioni possibili
            for direction in directions:
                # Calcolare la nuova posizione applicando l'offset alla posizione iniziale
                if position[0] == 0 and direction[0] < 0:
                    new_x = position[0]
                else:
                    new_x = position[0] + direction[0]
                if position[1] == 0 and direction[1] < 0:
                    new_y = position[1]
                else:
                    new_y = position[1] + direction[1]

                new_position = (new_x, new_y)
                print("NEW POSITION: ", new_position)
                # Controllare se la nuova posizione Ã¨ all'interno della griglia e vuota
                if self.within_bounds(new_position) and self.grid.is_cell_empty(
                    new_position
                ):
                    print("New position of the moving agent:", new_position)
                    moving_agent = MovingAgent(
                        1, self, self.grid, new_position, self.resources
                    )
                    self.add_resource(moving_agent, new_position[0], new_position[1])
                    self.schedule.add(moving_agent)
                    break  # Fermarsi quando viene trovata una casella libera
                else:
                    print("No empty cell found around position.")

--------------------------------------------------------------------------------------------
def begin_simulation(plugins):
    """
    Initiate the simulation by setting up required objects and running it.

    Returns:
        None
        :param plugins:
    """
    # Load data from external JSON files
    robot_data = None
    environment_data = None
    simulator_data = None
    isolated_area_tassels = []

    if os.path.exists("../SetUp/robot_file.json"):
        with open("../SetUp/robot_file.json") as f:
            robot_data = json.load(f)
    if os.path.exists("../SetUp/environment_file.json"):
        with open("../SetUp/environment_file.json") as f:
            environment_data = json.load(f)
    if os.path.exists("../SetUp/simulator_file.json"):
        with open("../SetUp/simulator_file.json") as f:
            simulator_data = json.load(f)
    # todo: in setup prende taglio - rimbalzo come plugin

    # Proceed with initialization regardless of existence of JSON files
    tassel_dim = simulator_data.get("tassel_dim", {}) if simulator_data else {}
    grid, resources, position = create_random_grid(
        environment_data, tassel_dim, isolated_area_tassels, plugins
    )

    if isolated_area_tassels is not []:
        random_tassel = random.choice(isolated_area_tassels)
        draw_line(
            position[0],
            position[1],
            random_tassel[0],
            random_tassel[1],
            grid,
            resources,
        )

        run_model_with_parameters(
            robot_data,
            grid,
            resources,
            simulator_data["repetitions"],
            simulator_data["cycles"],
            simulator_data["dim_tassel"],
        )

        # Add base station to the largest blocked area randomly
        biggest_area, coords = find_largest_blocked_area(grid)
    else:
        print("Base station position is None")
        """
        # Calculate position for the base station
       base_station_position = calculate_position(
            grid, False, coords, environment_data["width"], environment_data["length"]
        )

        add_base_station(grid, base_station_position, resources)
        run_model_with_parameters(robot_data, grid, resources, repetitions, cycle)

        # Add base station to the biggest area nearest to the center
        # Calculate position for the base station
        base_station_position1 = calculate_position(
            grid, True, coords, environment_data["width"], environment_data["length"]
        )

        add_base_station(grid, base_station_position1, resources)
        run_model_with_parameters(robot_data, grid, resources, repetitions, cycle)"""

--------------------------------------------------------


def create_random_grid(environment_data, tassel_dim, isolated_area_tassels, plugins):
    def get_value(key):
        return environment_data[key]

    (
        width,
        length,
        isolated_shape,
        min_height_blocked,
        max_height_blocked,
        min_width_blocked,
        max_width_blocked,
        num_blocked_squares,
        num_blocked_circles,
        radius,
        isolated_area_width,
        isolated_area_length,
        ray,
    ) = (
        get_value(k)
        for k in (
            "width",
            "length",
            "isolated_area_shape",
            "min_height_square",
            "max_height_square",
            "min_width_square",
            "max_width_square",
            "num_blocked_squares",
            "num_blocked_circles",
            "radius",
            "isolated_area_width",
            "isolated_area_length",
            "ray",
        )
    )

    grid = MultiGrid(int(width), int(length), torus=False)
    resources = []

    initialize_isolated_area(
        grid,
        isolated_shape,
        isolated_area_width,
        isolated_area_length,
        environment_data,
        isolated_area_tassels,
        radius,
        tassel_dim,
        resources,
    )

    populate_blocked_areas(
        resources,
        num_blocked_squares,
        num_blocked_circles,
        grid,
        min_width_blocked,
        max_width_blocked,
        min_height_blocked,
        max_height_blocked,
        ray,
        tassel_dim,
    )

    base_station = None
    while not base_station:
        base_station = generate_pair(width, length)

    position = add_base_station(
        grid,
        base_station,
        resources,
    )

    populate_perimeter_guidelines(int(width), int(length), grid, resources)

    return grid, resources, position








def run_model_with_parameters(
    robot_data, grid, resources, repetitions, cycles, dim_tassel
):
    """
    Run the simulation with the specified parameters.

    Args:
        robot_data (dict): Robot information.
        grid (MultiGrid): Grid to perform the simulation on.
        resources (list): Resources present in the grid.
        repetitions (int): Number of times the experiment should repeat.
        cycles (int): Length of each experiment.
        dim_tassel (float): Dimension of the tassel

    Returns:
        None
    """
    for _ in range(repetitions):
        for _ in range(cycles):
            # Start the simulation
            simulation = Simulator(grid, robot_data, resources, dim_tassel)
            simulation.step()





